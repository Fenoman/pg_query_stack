# Тестирование расширения pg_query_stack

## Структура тестов

Тесты разделены на отдельные файлы для лучшей изоляции и отладки:
- `sql/` - входные SQL-файлы с тестовыми запросами
- `expected/` - ожидаемые результаты выполнения тестов

## Описание тестов

### 001_setup.sql - Базовая установка и проверка
   - Устанавливает расширение и проверяет базовую работоспособность
   - Проверяет наличие функций pg_query_stack и pg_self_query
   - Ожидаемый результат: Успешная установка и базовая проверка

### 002_basic_functionality.sql - Базовая функциональность
   - Проверяет, что `SELECT * FROM pg_query_stack(0)` возвращает текущий запрос
   - Ожидаемый результат: 1 строка с frame_number=0 и query_text с 'pg_query_stack(0)'

### 003_skip_parameters.sql - Проверка параметров пропуска
   - Проверяет `pg_query_stack(1)` и `pg_query_stack()` (значение по умолчанию)
   - Ожидаемый результат: 0 строк для обоих вызовов

### 004_edge_cases.sql - Граничные случаи и валидация
   - Проверяет большие значения (1000, 100000) и отрицательные значения
   - Ожидаемый результат: Корректная обработка без исключений

### 005_nested_calls_default.sql - Вложенные вызовы (пропуск по умолчанию)
   - Создает функцию с pg_query_stack() и проверяет стек вызовов
   - Ожидаемый результат: 1 строка с вызовом функции (внутренний вызов пропущен)

### 006_nested_calls_full.sql - Вложенные вызовы (полный стек)
   - Создает функцию с pg_query_stack(0) и проверяет полный стек
   - Ожидаемый результат: 2 строки (вызов функции + внутренний вызов)

### 007_error_recovery.sql - Стабильность после ошибки
   - Выполняет деление на ноль, затем проверяет работу pg_query_stack
   - Ожидаемый результат: ERROR при делении, затем корректная работа функции

### 008_subtransactions.sql - Работа с подтранзакциями
   - Сложный тест с подтранзакциями, исключениями и откатами
   - Проверяет корректность работы xact_callback и очистки стека
   - Ожидаемый результат: Серия INFO сообщений, демонстрирующих стабильность

### 009_complex_nesting.sql - Сложные вложения и временные таблицы
   - Тестирует сложные сценарии с вложенными функциями и временными таблицами
   - Проверяет корректность стека при создании временных таблиц с pg_query_stack
   - Демонстрирует работу с разными параметрами skip_count в одной функции
   - Ожидаемый результат: Различные уровни детализации стека в зависимости от параметров

### 010_loop.sql - Нагрузочный тест с циклом
   - Нагрузочный тест с 1000 итераций вызовов функций
   - Проверяет стабильность расширения при интенсивной нагрузке
   - Тестирует отсутствие утечек памяти при многократных вызовах
   - Ожидаемый результат: Стабильная работа без ошибок памяти

### 011_triggers.sql - Работа с триггерами
   - Тестирует работу pg_query_stack в контексте триггеров AFTER INSERT/UPDATE
   - Проверяет корректность стека при каскадных операциях с временными таблицами
   - Использует REFERENCING для доступа к данным NEW и OLD
   - Ожидаемый результат: Корректное отображение полного стека вызовов через триггеры

### 012_stack_overflow.sql - Переполнение стека
   - Тестирует поведение при достижении максимальной глубины стека (MAX_QUERY_STACK_DEPTH = 100)
   - Проверяет корректность обрезания старых записей при переполнении
   - Использует рекурсивные вызовы для создания глубокого стека
   - Ожидаемый результат: Стабильная работа без переполнения памяти

### 013_query_length_limit.sql - Ограничение длины запроса
   - Тестирует обрезание слишком длинных запросов (MAX_QUERY_TEXT_LENGTH = 512Kb)
   - Проверяет защиту от переполнения памяти при очень длинных запросах
   - Использует множественные UNION ALL для создания длинного текста
   - Ожидаемый результат: Корректное обрезание или обработка длинных запросов

### 014_cte_recursive.sql - CTE и рекурсивные запросы
   - Тестирует работу с Common Table Expressions (CTE)
   - Проверяет корректность отслеживания рекурсивных CTE
   - Тестирует вложенные CTE в функциях
   - Ожидаемый результат: Корректное отображение CTE в стеке запросов

## Запуск тестов

### Сборка и установка расширения

```bash
# Компилируем расширение
make clean
make

# Устанавливаем в PostgreSQL
sudo make install
```

### Запуск регрессионных тестов

#### Автоматический запуск (рекомендуется)

```bash
# Запуск всех тестов с автоматической сборкой и установкой
./run_tests.sh

# Запуск отдельного теста
./run_single_test.sh 001_setup
./run_single_test.sh 007_error_recovery
```

#### Ручной запуск

```bash
# Запуск всех тестов
make installcheck

# Запуск конкретного теста
make installcheck REGRESS=001_setup
make installcheck REGRESS=002_basic_functionality
# и т.д.

# Запуск нескольких тестов
make installcheck REGRESS="001_setup 002_basic_functionality 003_skip_parameters"
```

### Ручной запуск тестов

```bash
# Подключаемся к PostgreSQL
psql -d your_database

# Запускаем отдельные тесты
\i sql/001_setup.sql
\i sql/002_basic_functionality.sql
# и т.д.
```

## Интерпретация результатов

### Успешное выполнение

При успешном выполнении тестов вы увидите:
```
============== running regression test queries ==============
test 001_setup                ... ok
test 002_basic_functionality  ... ok
test 003_skip_parameters      ... ok
test 004_edge_cases           ... ok
test 005_nested_calls_default ... ok
test 006_nested_calls_full    ... ok
test 007_error_recovery       ... ok
test 008_subtransactions      ... ok
test 009_complex_nesting      ... ok
test 010_loop                 ... ok
test 011_triggers             ... ok
test 012_stack_overflow       ... ok
test 013_query_length_limit   ... ok
test 014_cte_recursive        ... ok
============== All 16 tests passed. ==============
```

### Ошибки

При наличии ошибок создаются файлы:
- `results/test_name.out` - фактический результат для конкретного теста
- `regression.diffs` - различия между ожидаемым и фактическим результатом

Пример для неудачного теста:
- `results/002_basic_functionality.out` - фактический результат
- Дифф покажет различие с `expected/002_basic_functionality.out`

## Добавление новых тестов

Для добавления новых тестов:

1. Создайте новый `.sql` файл в директории `sql/`
2. Создайте соответствующий `.out` файл в директории `expected/`
3. Добавьте имя теста в переменную `REGRESS` в Makefile
4. Изменить документацию TESTING.md
5. Изменить run_single_test.sh
6. Изменить run_tests.sh

## Не забывайте!

- Тесты зависят от точного совпадения выходных данных
- Форматирование и пробелы в выводе должны точно соответствовать ожидаемому
- При изменении логики функций необходимо обновить файлы в `expected/`